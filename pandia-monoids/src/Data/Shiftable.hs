{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE DerivingVia                #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE ScopedTypeVariables        #-}
{-# LANGUAGE TypeFamilies               #-}
{-# LANGUAGE FlexibleContexts           #-}
{-# LANGUAGE RankNTypes                 #-}
{-# LANGUAGE TypeApplications           #-}
{-# LANGUAGE AllowAmbiguousTypes        #-}
{-# LANGUAGE DefaultSignatures          #-}

--------------------------------------------------------------------------------
-- |
--
-- Module      :  Pandia.Core.Media.Internal
-- Description :  Actions of sets, semigroups, monoids or groups.
-- Copyright   :  (c) Alice Rixte 2024
-- License     :  LGPL 3
-- Maintainer  :  alice.rixte@u-bordeaux.fr
-- Stability   :  unstable
-- Portability :  non-portable (GHC extensions)
--
-- == Presentation
--
-- Left actions of sets, semigroups, monoids or groups. An action lifts an
-- element of some type @s@, which we in this documentation we will call the
-- /acting/ type ot the /actor/ into a function of another type @x@ which we
-- call the /actee/.
--
-- == Examples
--
-- == Design choices compared with existing libraries
--
--------------------------------------------------------------------------------

module Data.Shiftable
  (
    Shift
  , Origin (..)
  , fromOrigin
  , maybeOrigin
  ) where

import Data.Monoid as Mn
import Data.Functor.Identity
import Data.Coerce
import Data.Maybe (fromMaybe)

import Data.Act

------------------------------------ Origin ------------------------------------

class Origin s where
  origin :: s

instance Num x => Origin (Sum x) where
  origin = 0
  {-# INLINE origin #-}

instance Num x => Origin (Product x) where
  origin = 1
  {-# INLINE origin #-}

instance Origin Any where
  origin = Any False
  {-# INLINE origin #-}

instance Origin All where
  origin = All True
  {-# INLINE origin #-}

instance Origin (Mn.First a) where
  origin = Mn.First Nothing
  {-# INLINE origin #-}

instance Origin (Mn.Last a) where
  origin = Mn.Last Nothing
  {-# INLINE origin #-}


instance Origin (Maybe x) where
  origin = Nothing
  {-# INLINE origin #-}

instance Origin x => Origin (Identity x) where
  origin = Identity origin
  {-# INLINE origin #-}

instance Origin [a] where
  origin = []
  {-# INLINE origin #-}

fromOrigin :: Origin x => Maybe x -> x
fromOrigin = maybe origin id
{-# INLINE fromOrigin #-}

type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
type Lens' s a = Lens s s a a

maybeOrigin :: Origin a => Lens' (Maybe a) a
maybeOrigin f a = fmap Just (f (fromMaybe origin a))
{-# INLINE maybeOrigin #-}

------------------------------------ Shift -------------------------------------

type family Shift s



-- | A set @x@ that can be lifted in some semigroup @s@.
--
-- Instances must satisfy the following law
--
-- @lshift x <>$ origin == x@
--
-- This is a generalisation of a G-torsor
-- --
-- class (LActSg x s, Semigroup s, Origin x) => LShiftable x s where
--   lshift :: x -> s

-- instance (Origin s, Semigroup s) => LShiftable s (ActSelf s) where
--   lshift = ActSelf

-- instance (Semigroup s, Coercible x s, Origin x)
--   => LShiftable x (ActSelf' s) where
--   lshift = ActSelf' . coerce
--   {-# INLINE lshift #-}

-- instance LShiftable x s => LShiftable (Identity x) (Identity s) where
--   lshift = coerce (lshift :: x -> s)
--   {-# INLINE lshift #-}



-- class (LAct s (Shift s), Semigroup (Shift s)) => Shiftable s where
--   type Shift s
--   shift :: s -> Shift s

-- instance Num x => Shiftable (Sum x) where
--   type Shift (Sum x) = Sum x
--   shift = id
--   {-# INLINE shift #-}

-- instance Num x => Shiftable (Product x) where
--   type Shift (Product x) = Product x
--   shift = id
--   {-# INLINE shift #-}

-- instance Shiftable x => Shiftable (Identity x) where
--   type Shift (Identity x) = Identity (Shift x)
--   shift = coerce . shift
--   {-# INLINE shift #-}


------------------------------------------------------------------------------


-- | A left action generated by a subset of generators @'lgenerators'@.
--
-- [Algebraic definition :]
--
-- In algebraic terms, a subset @u@ of the set @x@ is a /generating set/ of the
-- action @LAct x s@ if for every @x :: x@, there exists a pair @(u,s) ::
-- (u,s)@. When the set @u@ is finite, the action @LAct x s@ is said to be
-- finitely generated. When @u@ is a singleton, the action is said to be
-- /cyclic/ (see @'LActCyclic'@). (See /Monoids, Acts and Categories/ by Mati
-- Kilp, Ulrich Knauer, Alexander V. Mikhalev, definition 1.5.1, p.63.)
--
-- [In Haskell terms :]
--
-- Intuitively, this means that by acting repeteadly on generators with actions
-- of @s@, we can reach any element of @x@.
--
-- Since the generating subset of @x@ maybe infinite, we give two alternative
-- ways to define it : one using a characteristic function @'lgenerators'@ and
-- the other using a list @'lgeneratorsList'@.
--
-- All the above is summarized by the following law that all instances must
-- satisfy :
--
-- 1. @'lgenerators'@ proxy ('fst' $ 'lshiftFromGen' x) == True@
-- 2. @'snd' @('lshiftFromGen' x) <>$ 'fst' ('lshiftFromGen' x) == x@
-- 3. @'lgenerators' proxy x == x `'elem'` 'lgeneratorsList' proxy@
--
-- [Example :]
--
-- Suppose we want to make the distinction between timestamps, which are dates that cannot be additioned, and durations, which can be summed.
--
-- newtype Timestamp a = Timestamp a
--
-- newtype Duration a = Duration a
--   deriving (Semigroup, Monoid) via (Sum a)
--
class LActGen x s where
  -- | The set of origins of the action @LAct x s@.
  --
  -- This is a subset of @x@, represented as its characteristic function,
  -- meaning the function that returns @True@ for all elements of @x@ that are
  -- origins of the action and @False@ otherwise.
  --
  lgenerators' :: x -> Bool
  default lgenerators' :: Eq x => x -> Bool
  lgenerators' x = x `elem` lgeneratorsList' @x @s

  -- | The set of origins of the action @LAct x s@ seen as a list.
  --
  -- You can let this function undefined if the set of origins cannot be
  -- represented as a list.
  --
  lgeneratorsList' :: [x]

  -- | Returns a point's associated origin @o@ along with an action @s@ such
  -- that @s <>$ o == x@.
  lshiftFromGen:: x -> (x,s)

lgenerators :: forall s x. LActGen x s => x -> Bool
lgenerators = lgenerators' @x @s
{-# INLINE lgenerators #-}

lgeneratorsList :: forall s x. LActGen x s => [x]
lgeneratorsList = lgeneratorsList' @x @s
{-# INLINE lgeneratorsList #-}




-- class Semigroup' x where
--   mappend' :: x -> x -> x
--   mappend' :: Monoid

-- class Monoid' x where
--   mempty' :: x

newtype Timestamp a = Timestamp a
  deriving stock (Show, Read, Eq, Ord)


newtype Duration a = Duration a
  deriving stock (Show, Read, Eq, Ord)
  deriving (Semigroup, Monoid) via (Sum a)
  deriving (LAct (Timestamp a), LActGen (Timestamp a))
    via (ActSelf' (Sum a))


origins :: forall s x. LActGen x s => [x]
origins = lgeneratorsList @s
-- instance LActMn (Timestamp a) (Duration a)  where





-- class LActFiniteFree x s => OneFree x s where
--   origin :: poxy s -> x

instance (Eq x, Coercible x s, Monoid s) => LActGen x (ActSelf' s) where
  lgenerators' x = x == coerce (mempty :: s)
  lgeneratorsList' = [coerce (mempty :: s)]
  lshiftFromGen x = (coerce (mempty :: s), coerce x :: ActSelf' s)


instance (Eq x, Num x) => LActGen x (Sum x) where
  lgenerators' = lgeneratorsDefault @(Sum x)
  lgeneratorsList' = lgeneratorsListDefault @(Sum x)
  lshiftFromGen = lshiftFromGenDefault

instance (Eq x, Num x) => LActCyclic x (Sum x) where
  lorigin' = 0
  {-# INLINE lorigin' #-}
  lshift = Sum
  {-# INLINE lshift #-}



class LActGen x s => LActCyclic x s where
  lorigin' :: x
  lshift :: x -> s

lorigin :: forall s x. LActCyclic x s => x
lorigin = lorigin' @x @s
{-# INLINE lorigin #-}

lgeneratorsDefault :: forall s x. (Eq x, LActCyclic x s) => x -> Bool
lgeneratorsDefault x = x == lorigin @s
{-# INLINE lgeneratorsDefault #-}

lgeneratorsListDefault :: forall s x. LActCyclic x s => [x]
lgeneratorsListDefault = [lorigin @s]
{-# INLINE lgeneratorsListDefault #-}

lshiftFromGenDefault :: forall s x. LActCyclic x s => x -> (x,s)
lshiftFromGenDefault x = (lorigin @s, lshift x)
{-# INLINE lshiftFromGenDefault #-}



