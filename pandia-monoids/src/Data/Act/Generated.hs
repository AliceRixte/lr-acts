{-# LANGUAGE AllowAmbiguousTypes    #-}
{-# LANGUAGE TypeApplications       #-}
{-# LANGUAGE ScopedTypeVariables    #-}
{-# LANGUAGE DefaultSignatures      #-}
{-# LANGUAGE FlexibleInstances      #-}
{-# LANGUAGE MultiParamTypeClasses  #-}

module Data.Act.Generated where


import Data.Coerce
import Data.Semigroup as Sg
import Data.Monoid as Mn


import Data.Act

-- | A left action generated by a subset of generators @'lgenerators'@.
--
-- [Algebraic definition :]
--
-- In algebraic terms, a subset @u@ of the set @x@ is a /generating set/ of the
-- action @LAct x s@ if for every @x :: x@, there exists a pair @(u,s) ::
-- (u,s)@. When the set @u@ is finite, the action @LAct x s@ is said to be
-- finitely generated. When @u@ is a singleton, the action is said to be
-- /cyclic/ (see @'LActCyclic'@). (See /Monoids, Acts and Categories/ by Mati
-- Kilp, Ulrich Knauer, Alexander V. Mikhalev, definition 1.5.1, p.63.)
--
-- [In Haskell terms :]
--
-- Intuitively, this means that by acting repeteadly on generators with actions
-- of @s@, we can reach any element of @x@.
--
-- Since the generating subset of @x@ maybe infinite, we give two alternative
-- ways to define it : one using a characteristic function @'lgenerators'@ and
-- the other using a list @'lgeneratorsList'@.
--
-- All the above is summarized by the following law that all instances must
-- satisfy :
--
-- 1. 'lgenerators'@ proxy ('fst' $ 'lshiftFromGen' x) == True@
-- 2. 'snd' @('lshiftFromGen' x) <>$ 'fst' ('lshiftFromGen' x) == x@
-- 3. 'lgenerators' @proxy x == x `'elem'` 'lgeneratorsList' proxy@
--
-- [Example :]
--
-- Suppose we want to make the distinction between timestamps, which are dates that cannot be additioned, and durations, which can be summed.
--
-- newtype Timestamp a = Timestamp a
--
-- newtype Duration a = Duration a
--   deriving (Semigroup, Monoid) via (Sum a)
--
class LActGen x s where
  -- | The set of origins of the action @LAct x s@.
  --
  -- This is a subset of @x@, represented as its characteristic function,
  -- meaning the function that returns @True@ for all elements of @x@ that are
  -- origins of the action and @False@ otherwise.
  --
  lgenerators' :: x -> Bool
  default lgenerators' :: Eq x => x -> Bool
  lgenerators' x = x `elem` lgeneratorsList' @x @s

  -- | The set of origins of the action @LAct x s@ seen as a list.
  --
  -- You can let this function undefined if the set of origins cannot be
  -- represented as a list.
  --
  lgeneratorsList' :: [x]
  default lgeneratorsList' :: LActCyclic x s => [x]
  lgeneratorsList' = [lorigin @s]

  -- | Returns a point's associated origin @o@ along with an action @s@ such
  -- that @s <>$ o == x@.
  lshiftFromGen:: x -> (x,s)
  default lshiftFromGen :: LActCyclic x s => x -> (x,s)
  lshiftFromGen x = (lorigin @s, lshift x)

lgenerators :: forall s x. LActGen x s => x -> Bool
lgenerators = lgenerators' @x @s
{-# INLINE lgenerators #-}

lgeneratorsList :: forall s x. LActGen x s => [x]
lgeneratorsList = lgeneratorsList' @x @s
{-# INLINE lgeneratorsList #-}

origins :: forall s x. LActGen x s => [x]
origins = lgeneratorsList @s
{-# INLINE origins #-}

-- | A left action generated by a single generator.
--
-- Instances must satisfy the following laws :
--
-- 1. 'lgeneratorsList' @ == ['lorigin']@
-- 2. 'lshiftFromGen' x @ == ('lorigin', 'lshift' x)@
--
-- Intuitively, this generator can be seen as the origin of @x@. Every element
-- @x::x@ can be seen as an element @'lshift' x :: s@ such that @'lshift' x <>$
-- lorigin == x@
--
class LActGen x s => LActCyclic x s where
  lorigin' :: x
  lshift :: x -> s

lorigin :: forall s x. LActCyclic x s => x
lorigin = lorigin' @x @s
{-# INLINE lorigin #-}


-- newtype Timestamp a = Timestamp a
--   deriving stock (Show, Read, Eq, Ord)


-- newtype Duration a = Duration a
--   deriving stock (Show, Read, Eq, Ord)
--   deriving (Semigroup, Monoid) via (Sum a)
--   deriving (LAct (Timestamp a), LActGen (Timestamp a))
--     via (ActSelf' (Sum a))



instance (Eq x, Coercible x s, Monoid s) => LActGen x (ActSelf' s)

instance (Eq x, Coercible x s, Monoid s) => LActCyclic x (ActSelf' s) where
  lorigin' = coerce (mempty :: s)
  {-# INLINE lorigin' #-}
  lshift = coerce
  {-# INLINE lshift #-}


instance (Eq x, Num x) => LActGen x (Sum x)

instance (Eq x, Num x) => LActCyclic x (Sum x) where
  lorigin' = 0
  {-# INLINE lorigin' #-}
  lshift = Sum
  {-# INLINE lshift #-}

